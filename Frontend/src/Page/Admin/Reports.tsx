import { useState } from "react";
import { format, isAfter, isBefore, startOfDay } from "date-fns";
import { toast } from "sonner";

import {
  Card,
  CardHeader,
  CardTitle,
  CardDescription,
  CardContent,
} from "@/Components/ui/card";
import { Label } from "@/components/ui/label";
import { Button } from "@/Components/ui/button";
import {
  Select,
  SelectTrigger,
  SelectValue,
  SelectContent,
  SelectItem,
} from "@/Components/ui/select";
import { Calendar } from "@/Components/ui/calendar";
import {
  Popover,
  PopoverTrigger,
  PopoverContent,
} from "@/Components/ui/popover";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";

import {
  FileText,
  FileSpreadsheet,
  Loader2,
  Eye,
  X,
  Download,
  BarChart,
  AlertCircle,
  DollarSign,
  Calendar as CalendarIcon,
} from "lucide-react";

import { Breadcrumb } from "@/Components/Breadcrumb";
import { ReportPreview } from "@/Components/admin/ReportPreview";
import { adminApi } from "@/lib/api";
import { cn } from "@/lib/utils";
import ExcelJS from "exceljs";
import { saveAs } from "file-saver";
import jsPDF from "jspdf";
import autoTable from "jspdf-autotable";

type ReportType = "meter-readings" | "revenue" | "customer-complaints";

interface ReportFilters {
  startDate: string;
  endDate: string;
  department?: string;
  userGroup?: string;
}
interface ReportData {
  reportType: string;
  generatedBy?: string;
  generatedAt: string;
  filters?: ReportFilters;
  data: any;
}

const REPORT_TYPES = [
  {
    value: "meter-readings",
    label: "Meter Readings",
    icon: <BarChart className="h-4 w-4" />,
    description: "View all meter reading records and payment statuses",
  },
  {
    value: "revenue",
    label: "Revenue Analysis",
    icon: <DollarSign className="h-4 w-4" />,
    description: "Analyze revenue trends and payment summaries",
  },
  {
    value: "customer-complaints",
    label: "Customer Complaints",
    icon: <AlertCircle className="h-4 w-4" />,
    description: "Track and manage customer complaint resolutions",
  },
];

const AdminReports = () => {
  const [startDate, setStartDate] = useState<Date>();
  const [endDate, setEndDate] = useState<Date>();
  const [reportType, setReportType] = useState<ReportType>("meter-readings");
  const [reportData, setReportData] = useState<ReportData | null>(null);
  const [isGenerating, setIsGenerating] = useState(false);
  const [isExporting, setIsExporting] = useState(false);
  const [showPreview, setShowPreview] = useState(false);
  const [showExportModal, setShowExportModal] = useState(false);

  const validateDates = () => {
    if (!startDate || !endDate) {
      toast.error("Please select both start and end dates");
      return false;
    }
    if (isAfter(startDate, new Date())) {
      toast.error("Start date cannot be in the future");
      return false;
    }
    if (isAfter(startDate, endDate)) {
      toast.error("Start date cannot be after end date");
      return false;
    }
    return true;
  };
  const formatReportType = (type: string) => {
    const types: Record<string, string> = {
      "officer-report": "Officer Activity Report",
      "meter-readings": "Meter Readings Report",
      revenue: "Revenue Analysis Report",
      "customer-complaints": "Customer Complaints Report",
    };
    return types[type] || type;
  };

  const handleGenerateReport = async () => {
    if (!validateDates()) return;
    setIsGenerating(true);
    setReportData(null);

    try {
      console.log("report type", reportType);
      const data = await adminApi.generateReport(reportType, {
        startDate: format(startDate!, "yyyy-MM-dd"),
        endDate: format(endDate!, "yyyy-MM-dd"),
      });

      if (data.success) {
        setReportData(data);
        toast.success("Report generated successfully");
      } else {
        toast.error(data.message || "Failed to generate report");
      }
    } catch (error: any) {
      console.error(error);
      toast.error("Failed to generate report. Please check the server.");
    } finally {
      setIsGenerating(false);
    }
  };

  const exportExcelFrontend = async (reportData: ReportData) => {
    const workbook = new ExcelJS.Workbook();
    const ws = workbook.addWorksheet("Report Data");

    ws.mergeCells("A1:F1");
    const titleCell = ws.getCell("A1");
    titleCell.value = `${formatReportType(reportData.reportType)}`;
    titleCell.font = { size: 18, bold: true, color: { argb: "FF2563EB" } };
    titleCell.alignment = { horizontal: "center" };

    ws.mergeCells("A2:F2");
    ws.getCell("A2").value = `Generated on: ${new Date(
      reportData.generatedAt
    ).toLocaleString()}`;
    ws.getCell("A2").font = { size: 11, italic: true };

    ws.mergeCells("A3:F3");
    ws.getCell("A3").value = `Generated by: ${reportData.generatedBy}`;
    ws.getCell("A3").font = { size: 11, italic: true };

    ws.addRow([]);

    if (reportData.data.summary) {
      ws.addRow(["SUMMARY"]).font = { bold: true, size: 14 };
      Object.entries(reportData.data.summary).forEach(([k, v]) => {
        if (typeof v === "object") {
          ws.addRow([k, JSON.stringify(v)]);
        } else {
          ws.addRow([k, v]);
        }
      });
      ws.addRow([]);
    }

    const dataKey =
      reportData.reportType === "meter-readings"
        ? "readings"
        : reportData.reportType === "revenue"
        ? "payments"
        : reportData.reportType === "customer-complaints"
        ? "complaints"
        : "officers";

    if (reportData.data[dataKey]?.length) {
      ws.addRow(["DETAILED DATA"]).font = { bold: true, size: 14 };

      const headers = Object.keys(reportData.data[dataKey][0]);
      const headerRow = ws.addRow(headers);
      headerRow.eachCell((cell) => {
        cell.font = {
          bold: true,
          color: { argb: "FFFFFFFF" },
        };
        cell.fill = {
          type: "pattern",
          pattern: "solid",
          fgColor: { argb: "FF2563EB" },
        };
        cell.alignment = {
          vertical: "middle",
          horizontal: "center",
          wrapText: true,
        };
        cell.border = {
          top: { style: "thin" },
          left: { style: "thin" },
          bottom: { style: "thin" },
          right: { style: "thin" },
        };
      });

      reportData.data[dataKey].forEach((item: any) => {
        const values = Object.values(item).map((v) =>
          typeof v === "object" ? JSON.stringify(v) : v
        );
        ws.addRow(values);
      });

      ws.columns.forEach((column) => {
        column.width = 20;
      });
    }

    const buffer = await workbook.xlsx.writeBuffer();
    const fileName = `report_${reportData.reportType}_${format(
      new Date(),
      "yyyy-MM-dd_HH-mm"
    )}.xlsx`;
    saveAs(new Blob([buffer]), fileName);
  };

  const exportPDFFrontend = (reportData: ReportData) => {
    const doc = new jsPDF();

    doc.setFontSize(20);
    doc.setTextColor(37, 99, 235);
    doc.text(formatReportType(reportData.reportType), 14, 20);
    doc.setFontSize(10);
    doc.setTextColor(100);
    doc.text(
      `Generated on: ${new Date(reportData.generatedAt).toLocaleString()}`,
      14,
      30
    );
    doc.text(`Generated by: ${reportData.generatedBy}`, 14, 36);

    if (reportData.filters) {
      doc.text(
        `Period: ${reportData.filters.startDate} to ${reportData.filters.endDate}`,
        14,
        42
      );
    }

    let startY = 55;

    if (reportData.data.summary) {
      const summaryData = Object.entries(reportData.data.summary)
        .filter(([, v]) => typeof v !== "object")
        .map(([k, v]) => [
          k
            .replace(/([A-Z])/g, " $1")
            .replace(/^./, (str) => str.toUpperCase()),
          String(v),
        ]);

      if (summaryData.length > 0) {
        autoTable(doc, {
          startY,
          head: [["Metric", "Value"]],
          body: summaryData,
          theme: "striped",
          headStyles: { fillColor: [37, 99, 235] },
          styles: { fontSize: 10 },
        });
        startY = (doc as any).lastAutoTable?.finalY + 15 || startY + 50;
      }
    }

    // Detailed data
    const dataKey =
      reportData.reportType === "meter-readings"
        ? "readings"
        : reportData.reportType === "revenue"
        ? "payments"
        : reportData.reportType === "customer-complaints"
        ? "complaints"
        : "officers";

    if (reportData.data[dataKey]?.length) {
      const headers = Object.keys(reportData.data[dataKey][0]).map((h) =>
        h.replace(/([A-Z])/g, " $1").replace(/^./, (str) => str.toUpperCase())
      );
      const body = reportData.data[dataKey].map((item: any) =>
        Object.values(item).map((v) =>
          typeof v === "object" ? JSON.stringify(v) : String(v)
        )
      );

      autoTable(doc, {
        startY,
        head: [headers],
        body: body.slice(0, 20), // Limit rows for PDF
        theme: "striped",
        headStyles: { fillColor: [37, 99, 235], fontSize: 8 },
        styles: { fontSize: 8, cellPadding: 2 },
        columnStyles: { 0: { cellWidth: 25 } },
      });
    }

    // Footer
    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.setTextColor(150);
      doc.text(
        `Page ${i} of ${pageCount}`,
        doc.internal.pageSize.width / 2,
        doc.internal.pageSize.height - 10,
        { align: "center" }
      );
    }

    doc.save(
      `report_${reportData.reportType}_${format(
        new Date(),
        "yyyy-MM-dd_HH-mm"
      )}.pdf`
    );
  };

  const handleExport = async (formatType: "pdf" | "excel") => {
    if (!reportData) {
      toast.error("Generate a report first");
      return;
    }
    setIsExporting(true);

    try {
      if (formatType === "pdf") {
        exportPDFFrontend(reportData);
      } else {
        await exportExcelFrontend(reportData);
      }
      toast.success(`Report exported as ${formatType.toUpperCase()}`);
      setShowExportModal(false);
    } catch (error) {
      console.error(error);
      toast.error("Failed to export report");
    } finally {
      setIsExporting(false);
    }
  };

  const resetAll = () => {
    setStartDate(undefined);
    setEndDate(undefined);
    setReportType("meter-readings");
    setReportData(null);
  };

  const selectedReportInfo = REPORT_TYPES.find((r) => r.value === reportType);

  return (
    <div className="min-h-screen bg-background">
      <div className="container mx-auto px-4 py-8 max-w-4xl space-y-6 animate-fade-in">
        <Breadcrumb
          items={[
            { label: "Dashboard", href: "/dashboard" },
            { label: "Reports" },
          ]}
        />

        <div className="flex flex-col sm:flex-row sm:items-center justify-between gap-4">
          <div>
            <h1 className="text-3xl font-bold tracking-tight">
              Generate Reports
            </h1>
            <p className="text-muted-foreground mt-1">
              Select parameters and generate custom reports
            </p>
          </div>

          {reportData && (
            <div className="flex flex-wrap gap-2">
              <Button
                variant="outline"
                size="sm"
                onClick={() => setShowPreview(true)}
                className="gap-2"
              >
                <Eye className="h-4 w-4" /> Preview
              </Button>
              <Button
                size="sm"
                onClick={() => setShowExportModal(true)}
                className="gap-2"
              >
                <Download className="h-4 w-4" /> Export
              </Button>
              <Button
                variant="ghost"
                size="sm"
                onClick={resetAll}
                className="gap-2"
              >
                <X className="h-4 w-4" /> Clear
              </Button>
            </div>
          )}
        </div>

        {/* Form Card */}
        <Card>
          <CardHeader>
            <div className="flex items-center gap-3">
              <div className="p-2 rounded-lg bg-primary/10">
                <FileText className="h-5 w-5 text-primary" />
              </div>
              <div>
                <CardTitle>Report Configuration</CardTitle>
                <CardDescription>
                  Configure your report options below
                </CardDescription>
              </div>
            </div>
          </CardHeader>

          <CardContent className="space-y-6">
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
              {["startDate", "endDate"].map((key) => (
                <div key={key} className="space-y-2">
                  <Label htmlFor={key}>
                    {key === "startDate" ? "Start Date" : "End Date"}{" "}
                    <span className="text-destructive">*</span>
                  </Label>
                  <Popover>
                    <PopoverTrigger asChild>
                      <Button
                        id={key}
                        variant="outline"
                        className={cn(
                          "w-full justify-start text-left font-normal",
                          !(key === "startDate" ? startDate : endDate) &&
                            "text-muted-foreground"
                        )}
                      >
                        <CalendarIcon className="mr-2 h-4 w-4" />
                        {key === "startDate"
                          ? startDate
                            ? format(startDate, "PPP")
                            : "Select date"
                          : endDate
                          ? format(endDate, "PPP")
                          : "Select date"}
                      </Button>
                    </PopoverTrigger>
                    <PopoverContent className="w-auto p-0" align="start">
                      <Calendar
                        mode="single"
                        selected={key === "startDate" ? startDate : endDate}
                        onSelect={
                          key === "startDate" ? setStartDate : setEndDate
                        }
                        disabled={(date) =>
                          isAfter(date, new Date()) ||
                          (key === "startDate"
                            ? endDate
                              ? isAfter(date, endDate)
                              : false
                            : startDate
                            ? isBefore(date, startDate)
                            : false)
                        }
                        initialFocus
                      />
                    </PopoverContent>
                  </Popover>
                </div>
              ))}
            </div>

            <div className="space-y-2">
              <Label htmlFor="report-type">
                Report Type <span className="text-destructive">*</span>
              </Label>
              <Select
                value={reportType}
                onValueChange={(value: ReportType) => {
                  setReportType(value);
                  setReportData(null);
                }}
              >
                <SelectTrigger id="report-type">
                  <SelectValue placeholder="Select report type" />
                </SelectTrigger>
                <SelectContent>
                  {REPORT_TYPES.map((type) => (
                    <SelectItem key={type.value} value={type.value}>
                      <div className="flex items-center gap-2">
                        {type.icon}
                        <span>{type.label}</span>
                      </div>
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              {selectedReportInfo && (
                <p className="text-sm text-muted-foreground">
                  {selectedReportInfo.description}
                </p>
              )}
            </div>

            <Button
              onClick={handleGenerateReport}
              className="w-full"
              size="lg"
              disabled={isGenerating || !startDate || !endDate}
            >
              {isGenerating ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />{" "}
                  Generating...
                </>
              ) : (
                <>
                  <FileText className="mr-2 h-4 w-4" /> Generate Report
                </>
              )}
            </Button>
          </CardContent>
        </Card>

        <ReportPreview
          open={showPreview}
          onOpenChange={setShowPreview}
          reportData={reportData}
        />

        <Dialog open={showExportModal} onOpenChange={setShowExportModal}>
          <DialogContent className="sm:max-w-md">
            <DialogHeader>
              <DialogTitle>Export Report</DialogTitle>
              <DialogDescription>
                Choose your preferred export format
              </DialogDescription>
            </DialogHeader>
            <div className="grid grid-cols-2 gap-4 pt-4">
              <Button
                variant="outline"
                className="h-24 flex-col gap-2"
                onClick={() => handleExport("pdf")}
                disabled={isExporting}
              >
                {isExporting ? (
                  <Loader2 className="h-6 w-6 animate-spin" />
                ) : (
                  <FileText className="h-6 w-6 text-destructive" />
                )}
                <span>PDF Document</span>
              </Button>
              <Button
                variant="outline"
                className="h-24 flex-col gap-2"
                onClick={() => handleExport("excel")}
                disabled={isExporting}
              >
                {isExporting ? (
                  <Loader2 className="h-6 w-6 animate-spin" />
                ) : (
                  <FileSpreadsheet className="h-6 w-6 text-green-600" />
                )}
                <span>Excel Spreadsheet</span>
              </Button>
            </div>
          </DialogContent>
        </Dialog>
      </div>
    </div>
  );
};

export default AdminReports;
